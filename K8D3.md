# Kubernetes Day 3 — Services & Networking

This document consolidates the Day 3 lesson on **Kubernetes Services** along with extended explanations, mental models, and hands-on exercises. The goal is to move from *"pods exist"* to *"services make systems usable"*.

These notes are written as a **reference**, not a tutorial transcript. Revisit them when debugging, designing, or explaining Kubernetes networking.

---

## 1. The Core Networking Problem in Kubernetes

Pods run containers, but **pods are not stable**.

Characteristics of pod networking:

* Every pod gets its own IP address
* Pod IPs are **cluster-internal only**
* Pod IPs **change** when pods restart or are replaced
* Multiple pods may exist for the same application

Relying on pod IPs directly introduces multiple failure modes:

* Hardcoded IPs break on pod restart
* No load balancing across replicas
* No stable identity for consumers

This makes direct pod-to-pod addressing unusable for real applications.

---

## 2. Services: Stable Network Abstractions

A **Service** provides a stable network endpoint in front of a dynamic set of pods.

Conceptually:

```
Client → Service → Pods
```

What a Service guarantees:

* A stable virtual IP
* A stable DNS name
* Automatic routing to healthy pods
* Load distribution across replicas

A Service does **not** run a container. It is a **virtual networking construct**, implemented via kube-proxy and node-level networking rules.

Pods may come and go. The Service persists.

---

## 3. Pod IPs vs Service IPs

Inspect pod IPs:

```bash
kubectl get pods -o wide
```

Example output:

```
NAME                          IP
my-app-xxxx                   10.42.0.15
my-app-yyyy                   10.42.0.16
```

These IPs:

* Only work inside the cluster
* Change when pods restart

Now inspect Services:

```bash
kubectl get services
```

Example:

```
NAME     TYPE       CLUSTER-IP      PORT(S)
my-app   ClusterIP  10.43.245.127   80/TCP
```

The **Service IP is stable**, even if all pods behind it are replaced.

---

## 4. How Services Find Pods (Labels & Selectors)

Services do not track pods by name or IP.

They use **label selectors**.

Example selector:

```
Selector: app=my-app
```

Pods created by the Deployment have matching labels:

```bash
kubectl get pods --show-labels
```

The Service dynamically resolves its **Endpoints**:

```bash
kubectl describe service my-app
```

Key fields:

* **Selector**: label query
* **Endpoints**: current pod IPs and ports

When pods are deleted or created, endpoints update automatically.

---

## 5. Service Types (High-Level Overview)

### ClusterIP (Default)

* Accessible only inside the cluster
* Gets a stable internal IP
* Used for internal service-to-service communication

### NodePort

* Opens a port on every node
* Accessible via `node-ip:nodePort`
* Useful for local testing and demos

### LoadBalancer

* Provisions an external load balancer
* Used in cloud environments
* Common in production

For local development, **ClusterIP + port-forward** is the most common pattern.

---

## 6. Creating a Service Imperatively

Expose a Deployment:

```bash
kubectl expose deployment my-app --port=80 --target-port=80
```

This creates:

* A Service named `my-app`
* A ClusterIP
* A selector matching `app=my-app`

Verify:

```bash
kubectl get svc
kubectl describe svc my-app
```

---

## 7. Accessing a ClusterIP Service (Port-Forward)

ClusterIP services are not accessible from your laptop directly.

Use port-forward:

```bash
kubectl port-forward service/my-app 8080:80
```

Traffic flow:

```
Browser → localhost:8080
kubectl tunnel
Service
Pod
nginx
```

Deleting pods while port-forward is active does **not** break connectivity.

---

## 8. Internal DNS and Service Discovery

Every Service gets a DNS name.

Inside the cluster:

```
my-app
my-app.default.svc.cluster.local
```

Applications should communicate using **names**, not IPs.

Test DNS resolution:

```bash
kubectl run test-pod \
  --image=busybox \
  --rm -it \
  --restart=Never \
  -- wget -qO- http://my-app
```

If DNS works, the Service abstraction is functioning correctly.

---

## 9. NodePort for External Access

Delete existing service:

```bash
kubectl delete svc my-app
```

Create NodePort:

```bash
kubectl expose deployment my-app --port=80 --type=NodePort
```

Inspect:

```bash
kubectl get svc my-app
```

Example:

```
80:31234/TCP
```

Access via:

```
http://localhost:31234
```

NodePort is useful for:

* Local testing
* Demos
* Temporary access

It is not the final production pattern.

---

## 10. Controlled Failure Experiments (Highly Recommended)

### Break the Selector

Edit the Service selector so it no longer matches pod labels.

Result:

* Endpoints list becomes empty
* Traffic stops

Lesson:
**Services route strictly based on labels.**

---

### Observe Endpoint Updates

```bash
kubectl get endpoints my-app -w
```

Delete pods and watch IPs rotate.

Lesson:
**Services adapt dynamically to pod churn.**

---

### Scale and Observe Load Distribution

```bash
kubectl scale deployment my-app --replicas=10
```

Observe how traffic continues to flow through the Service without changes.

Lesson:
**Load balancing is implicit and automatic.**

---

## 11. Namespaces and Service Scope

Services exist within namespaces.

Same service name in different namespaces = different services.

Example:

```bash
kubectl create namespace lab
kubectl apply -f deployment.yaml -n lab
kubectl expose deployment my-app -n lab --port=80
```

This is foundational for:

* Multi-tenant clusters
* Security isolation
* Environment separation

---

## 12. Key Mental Models to Retain

* Pods are ephemeral
* Services are stable
* Labels bind everything together
* DNS is the contract
* Services abstract volatility
* Kubernetes networking is declarative

---

## 13. What Comes Next

The imperative commands used here are for learning.

Real-world Kubernetes uses **declarative YAML manifests** for:

* Services
* Deployments
* Ingress
* Policies

The next step is defining Services and Deployments entirely in YAML.

---

## 14. Summary

By the end of this lesson, you should understand:

* Why pod IPs cannot be used directly
* How Services provide stable endpoints
* How labels and selectors drive routing
* How DNS enables service discovery
* When to use ClusterIP vs NodePort
* How Kubernetes maintains connectivity despite pod churn

This is the foundation of Kubernetes networking.
